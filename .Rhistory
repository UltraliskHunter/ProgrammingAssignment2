}
print(corr_vec)
}
corr <- function(directory = "RFiles/project1/specdata", threshold = 0){
Files_list <- dir(directory, full.names = T)
dat <- data.frame() #empty data frame for use in rbind
corr_vec <- vector()
else_vec <- NA
for(i in 1:332) { #loop through csv's binding them to one data frame
dat <- rbind(dat, read.csv(Files_list[i]))
}
for(i in 1:332) {
dat_sub <- dat[dat$ID == i, ]
if(sum(complete.cases(dat_sub)) > threshold) {
corr_hold <- cor(dat[dat$ID == i, c("sulfate", "nitrate")], use = "complete.obs", method = "pearson")
corr_vec <- c(corr_vec, corr_hold)
}
}
print(corr_vec)
}
dat_sub <- dat[dat$ID == i, ]
+         if(sum(complete.cases(dat_sub)) > threshold) {
+             corr_hold <- cor(dat[dat$ID == i, c("sulfate", "nitrate")], use = "complete.obs", method = "pearson")
+             corr_vec <- c(corr_vec, corr_hold)
.
//
corr <- function(directory = "RFiles/project1/specdata", threshold = 0){
Files_list <- dir(directory, full.names = T)
dat <- data.frame() #empty data frame for use in rbind
corr_vec <- vector()
else_vec <- NA
for(i in 1:332) { #loop through csv's binding them to one data frame
dat <- rbind(dat, read.csv(Files_list[i]))
}
for(i in 1:332) {
dat_sub <- dat[dat$ID == i, ]
if(sum(complete.cases(dat_sub)) > threshold) {
corr_hold <- cor(dat[dat$ID == i, c("sulfate", "nitrate")], use = "complete.obs", method = "pearson")
corr_vec <- c(corr_vec, corr_hold)
}
}
print(corr_vec)
}
dat_sub <- dat[dat$ID == 1, ]
if(sum(complete.cases(dat_sub)) > threshold) {
corr_hold <- cor(dat[dat$ID == 1, c("sulfate", "nitrate")], use = "complete.obs", method = "pearson")
corr_vec <- c(corr_vec, corr_hold)
..
//
corr <- function(directory = "RFiles/project1/specdata", threshold = 0){
Files_list <- dir(directory, full.names = T)
dat <- data.frame() #empty data frame for use in rbind
corr_vec <- vector()
else_vec <- NA
for(i in 1:332) { #loop through csv's binding them to one data frame
dat <- rbind(dat, read.csv(Files_list[i]))
}
for(i in 1:332) {
if(sum(complete.cases(dat[dat$ID == i, ])) > threshold) {
corr_hold <- cor(dat[dat$ID == i, c("sulfate", "nitrate")], use = "complete.obs", method = "pearson")
corr_vec <- c(corr_vec, corr_hold)
}
}
print(corr_vec)
}
corr(directory = "RFiles/project1/specdata", threshold = 400)
if(sum(complete.cases(dat[dat$ID == 1, ])) > 1) {
corr_hold <- cor(dat[dat$ID == 1, c("sulfate", "nitrate")], use = "complete.obs", method = "pearson")
corr_vec <- c(corr_vec, corr_hold)}
for(i in 1:332) { #loop through csv's binding them to one data frame
dat <- rbind(dat, read.csv(Files_list[i]))
}
dat <- data.frame() #empty data frame for use in rbind
for(i in 1:332) { #loop through csv's binding them to one data frame
dat <- rbind(dat, read.csv(Files_list[i]))
}
corr <- function(directory = "RFiles/project1/specdata", threshold = 0){
Files_list <- dir(directory, full.names = T)
dat <- data.frame() #empty data frame for use in rbind
corr_vec <- vector()
else_vec <- NA
for(i in 1:332) { #loop through csv's binding them to one data frame
dat <- rbind(dat, read.csv(Files_list[i]))
}
}
Files_list <- dir("RFiles/project1/specdata", full.names = T)
dat <- data.frame() #empty data frame for use in rbind
corr_vec <- vector()
for(i in 1:332) { #loop through csv's binding them to one data frame
dat <- rbind(dat, read.csv(Files_list[i]))
}}
for(i in 1:332) { #loop through csv's binding them to one data frame
dat <- rbind(dat, read.csv(Files_list[i]))
}
}
Files_list <- dir("RFiles/project1/specdata", full.names = T)
dat <- data.frame() #empty data frame for use in rbind
corr_vec <- vector()
for(i in 1:332) { #loop through csv's binding them to one data frame
dat <- rbind(dat, read.csv(Files_list[i]))
}
dat[dat$ID == 1, c("sulfate", "nitrate")]
cor(dat[dat$ID == 1, c("sulfate", "nitrate")], use = "complete.obs", method = "pearson")
corr <- function(directory = "RFiles/project1/specdata", threshold = 0){
Files_list <- dir(directory, full.names = T)
dat <- data.frame() #empty data frame for use in rbind
corr_vec <- vector()
else_vec <- NA
for(i in 1:332) { #loop through csv's binding them to one data frame
dat <- rbind(dat, read.csv(Files_list[i]))
}
for(i in 1:332) {
if(sum(complete.cases(dat[dat$ID == i, ])) > threshold) {
corr_hold <- cor(dat[dat$ID == i, c("sulfate", "nitrate")], use = "complete.obs", method = "pearson")
corr_hold2 <- cor_hold[1, 2]
corr_vec <- c(corr_vec, corr_hold2)
}
}
print(corr_vec)
}
corr(directory = "RFiles/project1/specdata", threshold = 600)
corr <- function(directory = "RFiles/project1/specdata", threshold = 0){
Files_list <- dir(directory, full.names = T)
dat <- data.frame() #empty data frame for use in rbind
corr_vec <- vector()
else_vec <- NA
for(i in 1:332) { #loop through csv's binding them to one data frame
dat <- rbind(dat, read.csv(Files_list[i]))
}
for(i in 1:332) {
if(sum(complete.cases(dat[dat$ID == i, ])) > threshold) {
corr_hold <- cor(dat[dat$ID == i, c("sulfate", "nitrate")], use = "complete.obs", method = "pearson")
corr_hold2 <- corr_hold[1, 2]
corr_vec <- c(corr_vec, corr_hold2)
}
}
print(corr_vec)
}
corr(directory = "RFiles/project1/specdata", threshold = 600)
corr(directory = "RFiles/project1/specdata", threshold = 400)
source("http://d396qusza40orc.cloudfront.net/rprog%2Fscripts%2Fsubmitscript1.R")
submit()
setwd("~/R/RFiles/project1")
submit()
submit
submit()
submit(3)
submit()
.
//
submit()
submit()
submit()
submit()
submit()
submit()
submit()
?subset
a <- c(1,1,1,1,2,2,2,2,2)
b <- c(10,12,15,12,NA,30,42,38,40)
s <- split(b, a)
s
lapply(s, mean)
a <- c(1,1,1,1,2,2,2,2,2)
b <- c(10,12,15,12,NA,30,42,38,40)
s <- split(a, b)
s
s <- split(b, a)
s
s <- split(b, a, na.rm = T)
s <- split(b, a)
lapply(s, mean, na.rm =T)
?spli
?split
subset()
?subset
?gl
?numeric
setwd("C:/Users/owner/ProgrammingAssignment2")
library(fortunes)
fortune("pizza")
makeVector <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setmean <- function(mean) m <<- mean
getmean <- function() m
list(set = set, get = get,
setmean = setmean,
getmean = getmean)
}
vec.test <- c(3, 5, 7)
makevector(vec.test)
makeVector(vec.test)
makeVector <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setmean <- function(mean) m <<- mean
getmean <- function() m
list(set = set, get = get,
setmean = setmean,
getmean = getmean)
}
cachemean <- function(x, ...) {
m <- x$getmean()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- mean(data, ...)
x$setmean(m)
m
}
makeVector(vec.test)
cachemean(makeVector(vec.test))
numeric(1,2)
x <- numeric()
x
?numeric
numeric(1)
numeric(6)
?mean
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
inverse.m <- NULL
set <- function(y) {
x <<- y
inverse.m <<- NULL
}
get <- function() x
setinv <- function(solve) inverse.m <<- solve
getinv <- function() inverse.m
list(set = set, get = get,
setinv = setinv,
getinv = getinv)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getinv()
if(!is.null(inverse.m)) {
message("getting cached data")
return(inverse.m)
}
data <- x$get()
inverse.m <- solve(data, ...)
x$setinv(inverse.m)
inverse.m
}
amatrix = makeCacheMatrix(matrix(c(1,2,3,4), nrow=2, ncol=2))
amatrix$get()
amatrix$getinv()
cacheSolve(amatrix)
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
inverse.m <- NULL
set <- function(y) {
x <<- y
inverse.m <<- NULL
}
get <- function() x
setinv <- function(solve) inverse.m <<- solve
getinv <- function() inverse.m
list(set = set, get = get,
setinv = setinv,
getinv = getinv)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getinv()
if(!is.null(inverse.m)) {
message("getting cached data")
return(inverse.m)
}
data <- x$get()
inverse.m <- solve(data, ...)
x$setinv(inverse.m)
inverse.m
}
amatrix = makeCacheMatrix(matrix(c(1,2,3,4), nrow=2, ncol=2))
amatrix$get()         # Returns original matrix
cacheSolve(amatrix)
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
inverse <- NULL
set <- function(y) {
x <<- y
inverse <<- NULL
}
get <- function() x
setinv <- function(solve) inverse <<- solve
getinv <- function() inverse
list(set = set, get = get,
setinv = setinv,
getinv = getinv)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getinv()
if(!is.null(inverse)) {
message("getting cached data")
return(inverse)
}
data <- x$get()
inverse <- solve(data, ...)
x$setinv(inverse)
inverse
}
amatrix = makeCacheMatrix(matrix(c(1,2,3,4), nrow=2, ncol=2))
amatrix$get()         # Returns original matrix
cacheSolve(amatrix)
amatrix$getinverse()  # Returns matrix inverse
cacheSolve(amatrix)
debug()
debug(cacheSolve)
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
inverse <- NULL
set <- function(y) {
x <<- y
inverse <<- NULL
}
get <- function() x
setinv <- function(solve) inverse <<- solve
getinv <- function() inverse
list(set = set, get = get,
setinv = setinv,
getinv = getinv)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getinv()
if(!is.null(inverse)) {
message("getting cached data")
return(inverse)
}
data <- x$get()
inverse <- solve(data)
x$setinv(inverse)
inverse
}
amatrix = makeCacheMatrix(matrix(c(1,2,3,4), nrow=2, ncol=2))
amatrix$get()         # Returns original matrix
cacheSolve(amatrix)
amatrix$getinverse()  # Returns matrix inverse
cacheSolve(amatrix)   # Returns cached matrix inverse using previously computed matrix inverse
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
inverse <- NULL
set <- function(y) {
x <<- y
inverse <<- NULL
}
get <- function() x
setinverse <- function(solve) inverse <<- solve
getinverse <- function() inverse
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getinverse()
if(!is.null(inverse)) {
message("getting cached data")
return(inverse)
}
data <- x$get()
inverse <- solve(data)
x$setinverse(inverse)
inverse
}
amatrix = makeCacheMatrix(matrix(c(1,2,3,4), nrow=2, ncol=2))
amatrix$get()         # Returns original matrix
cacheSolve(amatrix)   # Computes, caches, and returns    matrix inverse
amatrix$getinverse()  # Returns matrix inverse
cacheSolve(amatrix)   # Returns cached matrix inverse using previously computed matrix inverse
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
inverse <- NULL
set <- function(y) {
x <<- y
inverse <<- NULL
}
get <- function() x
setinverse <- function(solve) inverse <<- solve
getinverse <- function() inverse
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getinverse()
if(!is.null(inverse)) {
message("getting cached data")
return(inverse)
}
data <- x$get()
inverse <- solve(data)
x$setinverse(inverse)
inverse
}
amatrix = makeCacheMatrix(matrix(c(1,2,3,4), nrow=2, ncol=2))
amatrix$get()         # Returns original matrix
cacheSolve(amatrix)   # Computes, caches, and returns    matrix inverse
amatrix$getinverse()  # Returns matrix inverse
cacheSolve(amatrix)   # Returns cached matrix inverse using previously computed matrix inverse
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
inverse <- NULL
set <- function(y) {
x <<- y
inverse <<- NULL
}
get <- function() x
setinverse <- function(solve) inverse <<- solve
getinverse <- function() inverse
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## Write a short comment describing this function
cacheSolve <- function(x) {
## Return a matrix that is the inverse of 'x'
m <- x$getinverse()
if(!is.null(inverse)) {
message("getting cached data")
return(inverse)
}
data <- x$get()
inverse <- solve(data)
x$setinverse(inverse)
inverse
}
amatrix = makeCacheMatrix(matrix(c(1,2,3,4), nrow=2, ncol=2))
amatrix$get()         # Returns original matrix
cacheSolve(amatrix)   # Computes, caches, and returns    matrix inverse
amatrix$getinverse()  # Returns matrix inverse
cacheSolve(amatrix)   # Returns cached matrix inverse using previously computed matrix inverse
debug
debug(cacheSolve)
trackback()
cacheSolve(amatrix)   # Computes, caches, and returns    matrix inverse
1
2
3
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
inverse <- NULL
set <- function(y) {
x <<- y
inverse <<- NULL
}
get <- function() x
setinverse <- function(solve) inverse <<- solve
getinverse <- function() inverse
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inverse <- x$getinverse()
if(!is.null(inverse)) {
message("getting cached data")
return(inverse)
}
data <- x$get()
inverse <- solve(data, ...)
x$setinverse(inverse)
inverse
}
amatrix = makeCacheMatrix(matrix(c(1,2,3,4), nrow=2, ncol=2))
amatrix$get()         # Returns original matrix
cacheSolve(amatrix)   # Computes, caches, and returns    matrix inverse
amatrix$getinverse()  # Returns matrix inverse
cacheSolve(amatrix)   # Returns cached matrix inverse using previously computed matrix inverse
amatrix$set(matrix(c(0,5,99,66), nrow=2, ncol=2)) # Modify existing matrix
cacheSolve(amatrix)   # Computes, caches, and returns new matrix inverse
amatrix$get()         # Returns matrix
amatrix$getinverse()  # Returns matrix inverse
